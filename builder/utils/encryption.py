#!/usr/bin/env python3
# z-forge/builder/utils/encryption.py
"""
Encryption management for ZFS in Z-Forge
"""
import os
import subprocess
import logging
import secrets
import string
import hashlib
from typing import Dict, List, Optional, Tuple

class EncryptionManager:
    """
    Handles ZFS native encryption operations and key management
    """

    def __init__(self, config: Dict = None):
        self.logger = logging.getLogger('z-forge.encryption')
        self.config = config or {}

    def is_aesni_available(self) -> bool:
        """
        Check if the CPU supports AES-NI instructions for
        hardware-accelerated encryption
        """
        try:
            with open('/proc/cpuinfo', 'r') as f:
                cpuinfo = f.read()
            return 'aes' in cpuinfo
        except Exception as e:
            self.logger.warning(f"Failed to check AES-NI support: {str(e)}")
            return False

    def recommend_algorithm(self) -> str:
        """
        Recommend the best encryption algorithm based on hardware capabilities
        """
        if self.is_aesni_available():
            return "aes-256-gcm"
        else:
            return "chacha20-poly1305"

    def generate_keyfile(self, length: int = 32, output_path: str = None) -> Tuple[bytes, str]:
        """
        Generate a random keyfile for ZFS encryption

        Args:
            length: Length of the key in bytes
            output_path: Path to save the keyfile

        Returns:
            Tuple of (key_data, key_path)
        """
        # Generate random key
        key_data = secrets.token_bytes(length)

        if output_path:
            # Create directory if it doesn't exist
            os.makedirs(os.path.dirname(output_path), exist_ok=True)

            # Save key to file with restricted permissions
            with open(output_path, 'wb') as f:
                f.write(key_data)

            # Set permissions to read-only for owner
            os.chmod(output_path, 0o400)

            self.logger.info(f"Generated encryption keyfile: {output_path}")
            return key_data, output_path
        else:
            return key_data, None

    def generate_zfs_create_command(self,
                                    pool: str,
                                    dataset: str,
                                    encryption_enabled: bool = True,
                                    algorithm: str = "aes-256-gcm",
                                    pbkdf_iterations: int = 350000,
                                    key_format: str = "passphrase",
                                    compression: str = "lz4") -> str:
        """
        Generate a ZFS create command with proper encryption settings

        Args:
            pool: ZFS pool name
            dataset: Dataset name/path
            encryption_enabled: Whether encryption is enabled
            algorithm: Encryption algorithm
            pbkdf_iterations: Number of PBKDF2 iterations
            key_format: Key format (passphrase or raw)
            compression: Compression algorithm

        Returns:
            ZFS create command string
        """
        cmd = ["zfs", "create"]

        # Add encryption options if enabled
        if encryption_enabled:
            cmd.extend([
                "-o", f"encryption={algorithm}",
                "-o", f"keyformat={key_format}",
                "-o", "keylocation=prompt",
                "-o", f"pbkdf2iters={pbkdf_iterations}"
            ])

        # Add other ZFS options
        cmd.extend([
            "-o", f"compression={compression}",
            "-o", "acltype=posixacl",
            "-o", "xattr=sa",
            "-o", "relatime=on"
        ])

        # Add dataset path
        cmd.append(f"{pool}/{dataset}")

        return " ".join(cmd)

    def format_encryption_setup_script(self,
                                       algorithm: str = "aes-256-gcm",
                                       pbkdf_iterations: int = 350000) -> str:
        """
        Generate a shell script to set up ZFS encryption

        Args:
            algorithm: Encryption algorithm
            pbkdf_iterations: Number of PBKDF2 iterations

        Returns:
            Shell script content
        """
        script = f"""#!/bin/sh
# ZFS Encryption Setup Script
# Generated by Z-Forge Builder

# Check if running as root
if [ "$(id -u)" -ne 0 ]; then
    echo "This script must be run as root" >&2
    exit 1
fi

# Function to create encrypted dataset
create_encrypted_dataset() {{
    POOL="$1"
    DATASET="$2"

    echo "Creating encrypted dataset: $POOL/$DATASET"
    zfs create \\
        -o encryption={algorithm} \\
        -o keyformat=passphrase \\
        -o keylocation=prompt \\
        -o pbkdf2iters={pbkdf_iterations} \\
        -o compression=lz4 \\
        -o acltype=posixacl \\
        -o xattr=sa \\
        -o relatime=on \\
        "$POOL/$DATASET"

    return $?
}}

# Function to ensure pool is encrypted
check_encryption() {{
    POOL="$1"
    DATASET="$2"

    ENCRYPTION=$(zfs get -H -o value encryption "$POOL/$DATASET" 2>/dev/null)

    if [ "$ENCRYPTION" = "off" ]; then
        echo "WARNING: Dataset $POOL/$DATASET is not encrypted!"
        return 1
    else
        echo "Dataset $POOL/$DATASET is encrypted with: $ENCRYPTION"
        return 0
    fi
}}

# Main encryption setup
setup_encryption() {{
    POOL="$1"
    ROOT_DATASET="$2"

    # Create encrypted root dataset
    if [ -z "$ROOT_DATASET" ]; then
        ROOT_DATASET="ROOT/proxmox"
    fi

    # Prompt for password
    echo "Enter encryption passphrase for $POOL/$ROOT_DATASET:"
    create_encrypted_dataset "$POOL" "$ROOT_DATASET"

    if [ $? -ne 0 ]; then
        echo "Failed to create encrypted dataset!"
        return 1
    fi

    # Verify encryption is enabled
    check_encryption "$POOL" "$ROOT_DATASET"

    return 0
}}

# Parse arguments
if [ $# -lt 1 ]; then
    echo "Usage: $0 POOL [ROOT_DATASET]"
    exit 1
fi

POOL="$1"
ROOT_DATASET="$2"

setup_encryption "$POOL" "$ROOT_DATASET"
exit $?
"""
        return script
